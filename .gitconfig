[user]
  name = "Steven Hall"
  email = Hallzy.18@gmail.com
[core]
  editor = vim
[diff]
  tool = vimdiff
[merge]
  tool = vimdiff
  conflictstyle = diff3
[difftool]
  prompt = false
[mergetool]
  prompt = false
  keepBackup = false
[alias]
  co = checkout
  br = branch
  ci = commit -v
  st = status
  stat = status
  unstage = reset HEAD --
  graphlog = log --decorate --graph
  graphlogall = log --decorate --graph --all
  discard = checkout --
  amend = commit -a --amend

  # Show log as oneliner
  ls = log --pretty=format:"%C(yellow)%h\\ %ad%Cred%d\\ %Creset%s%Cgreen\\ [%cn]" --decorate --date=short
  lsgraphall = !git ls --decorate --graph --all

  # Same as ls but the lines after the commit show the files that are changed
  # and how many additions and deletions there were
  ll = log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cgreen\\ [%cn]" --decorate --numstat
  llgraphall = !git ll --decorate --graph --all

  # Reflog the way I like to see it
  rl = reflog --format='%C(yellow)%h %<|(17)%gd %C(green)%ci%C(reset) %s'

  # Prints out all my git aliases
  la = "!git config -l | grep alias | cut -c 7-"

  # Shows the log of only the commits affected by the last command in ll or ls format
  # eg, executing after a git pull will show you the commits that were pulled
  newll = !sh -c 'git ll $1@{1}..$1@{0} "$@"'
  newls = !sh -c 'git ls $1@{1}..$1@{0} "$@"'
  newlog = !sh -c 'git log $1@{1}..$1@{0} "$@"'
  new = !git newls

  newdifftool = !git difftool $1@{1}..$1@{0}

  # Does a pull and shows the commits that were pulled in ls or ll format
  pls = !git pull && git newls
  pll = !git pull && git newll

  # Removes a file from version control, but does not remove the file itself
  # eg. git rmvc file
  rmvc = rm --cached

  # Creates a remote branch of the same name of the current checked out branch
  # and sets up tracking with that branch
  track = !git push -u origin $(git rev-parse --symbolic-full-name --abbrev-ref HEAD)

  # Removes branches that are not being used anymore
  # eg. git rm-branch-auto-complete
  rm-branch-auto-complete = fetch --prune origin

  # Deletes a remote branch
  # eg. git delete-remote-branch issue#6
  delete-remote-branch = push origin --delete

  # Used when you want to remove all the uncommitted changes I have made. It
  # commits all these changes, and resets the working directory as if it was all
  # deleted. This means if need be, I can get that commit back with reflog
  # eg. git wipe
  wipe-all = !git add -A && git commit -qm 'WIPE SAVEPOINT' && git reset HEAD~1 --hard
  wipe-modified = !git commit -aqm 'WIPE SAVEPOINT' && git reset HEAD~1 --hard

  # Deletes a tag locally and remotely.
  delete-tag = "!f() { git push origin :refs/tags/$1; git tag -d $1; }; f"

  # deletes all branches already merged into master
  bclean = "!f() { git branch --merged ${1-master} | grep -v " ${1-master}$" | xargs -r git branch -d; }; f"

  # pulls changes from remote, removes remote-tracking branches that no longer
  # exist on remote
  up = !git pull --rebase --prune $@ && git submodule update --init --recursive

  # deletes the specified remote branch, checks out master, calls git up, and
  # calls git bclean
  bdone = "!f() { git delete-remote-branch $1 && git checkout ${2-master} && git up && git bclean ${2-master}; }; f"

  # does a git difftool of a givem commit, or HEAD if none is specified
  showtool = "!showci () { rev=${1:-HEAD}; git difftool $rev~1 $rev; }; showci $1"
[push]
  default = matching
[rebase]
	autosquash = true
